# Java Map 体系学习笔记
## 一、Map 接口核心方法与特性
Map 是 Java 中用于存储**键值对（Key-Value）** 的顶层接口，定义了所有键值对集合的通用操作，核心内容如下：

1. **添加元素**：`V put(K key, V value)`  
   - 功能：向集合中添加键值对；若键已存在，则覆盖原有值并返回旧值。
2. **删除元素**：`V remove(Object key)`  
   - 功能：根据指定的 `key` 删除对应的键值对，返回被删除的 `value`；若键不存在，返回 `null`。
3. **清空集合**：`void clear()`  
   - 功能：移除集合中所有的键值对，清空后集合长度为 0。
4. **判断键存在**：`boolean containsKey(Object key)`  
   - 功能：判断集合中是否包含指定的 `key`，存在返回 `true`，否则返回 `false`。
5. **判断值存在**：`boolean containsValue(Object value)`  
   - 功能：判断集合中是否包含指定的 `value`，存在返回 `true`，否则返回 `false`（注意：值可重复，只要有一个匹配即返回 `true`）。
6. **判断集合为空**：`boolean isEmpty()`  
   - 功能：判断集合中是否有键值对，为空返回 `true`，否则返回 `false`（与 `size() == 0` 效果一致）。
7. **获取集合长度**：`int size()`  
   - 功能：返回集合中键值对的个数（注意：原笔记中“int size”表述不完整，正确方法是带括号的 `size()`）。
8. **底层结构**：默认基于**哈希表**实现（不同实现类底层结构可能不同，如 TreeMap 基于红黑树）。


## 二、HashMap 实现类（Map 常用子类）
HashMap 是 Map 接口最常用的实现类，无额外特有方法，完全遵循 Map 接口定义，核心特性由“键（Key）”决定：

1. **核心特性**：
   - 无序：键值对的存储顺序与遍历顺序不一致（底层哈希表决定）。
   - 不重复：键（Key）不能重复，若添加重复键会覆盖旧值（基于 `equals()` 和 `hashCode()` 判断键是否重复）。
   - 无索引：不能通过索引（如数组下标）获取键值对，只能通过键（Key）查询值（Value）。

2. **底层结构与扩容机制**：
   - 结构：由**数组 + 链表**组成（JDK 1.8 后优化为“数组 + 链表 + 红黑树”）。
   - 初始容量：数组初始长度为 16（默认值，可通过构造方法自定义）。
   - 加载因子：0.75（当集合中键值对数量达到“当前容量 × 0.75”时，触发扩容，容量翻倍）。
   - 红黑树转换条件：当链表长度达到 8，且数组长度 ≥ 64 时，链表会自动转换为红黑树（目的是提高查询效率，红黑树查询时间复杂度为 O(logn)，链表为 O(n)）。


## 三、TreeMap 实现类（可排序的 Map 子类）
TreeMap 是 Map 接口的另一个重要实现类，底层与 TreeSet 一致，基于**红黑树**实现，核心特性同样由“键（Key）”决定：

1. **核心特性**：
   - 不重复：键（Key）不能重复，重复键会覆盖旧值（基于排序规则判断键是否重复）。
   - 无索引：无法通过索引获取键值对，只能通过键或排序顺序遍历。
   - 可排序：会对键（Key）进行自动排序（默认升序，可自定义排序规则）。

2. **两种排序规则（关键考点）**：
   - 方式 1：让键的类实现 `Comparable` 接口，重写 `compareTo()` 方法（**自然排序**）。  
     示例：若键是 `Integer`、`String` 等默认实现 `Comparable` 的类，会自动按升序排序；若自定义类作为键，需手动实现 `Comparable` 接口指定排序逻辑。
   - 方式 2：创建 TreeMap 时，通过构造方法传递 `Comparator` 比较器对象（**定制排序**）。  
     示例：即使键的类已实现 `Comparable`，也可通过 `Comparator` 覆盖默认排序规则（如将升序改为降序），灵活性更高。